General comments on the SaaS and UI:

The UI is in english, but input and output can be any language.

The UI is purely text based, like a scripted conversation with a chatbot.

The SaaS contains a list of apps the user can choose to run.
An admin user (normal user) can make sub users for free, so no cost per additional seat. Those sub users will use the admin users credits.
An admin user can make their own scripts, by oploading or editing a text file. This is not a visual programming interface.
Soon, the app making prompt above will be made into an app in purposewrite, so the user can make apps without having to learn the scripting language.
An admin can also choose to share an app they made with other specific admin users. They will then use their own credits to run the script and the creator will be given a kick back in the form of 10% of the other admins used credits.

NOTE: The scripts are meant to be run in one sitting, by one user.
However, the user can at any point while running a script make a "save point" and in the future come back to exactly that point in the app run, with any information given or generated being remembered.
This can be used to for example stop, save, go and get feedback from another person and then continue, or to store base data in the app for future runs based on the same base data.

Each time the script stops to let the user input an answer, it will show all the old answers to that question. That is, answers to that question variable on pervious app runs. This can help to speed up input in the future. 
The user can also give instructions to not remeber the answer by starting it with ## and also to remember the answer but give it a "display name" like this [display name] that will show up instead of the alswer on future runs. If chosen the full answer will be given, not the display name.  
As the entry save is based on the variable name, this could for example be used to make an app with several branches, where you can easily get back old base data from a previous run when you run a new branch.
Branching example at the app start, taking advantage of nameing the vars the same in the 2 branches:
1. Do Research
var: company name, website
2. Write the report
var: company name, website

Other APIs will be added in the future. Could for example be intergrations to CRM systems or design tools.


The language supports these commands:

## keywords are not case sensitive

## --- Comment Syntax (CRITICAL PARSING RULE) ---
## COMMENTS ARE DEFINED AS FOLLOWS:
## 1. A comment line MUST start with '##' at the VERY BEGINNING of the line.
## 2. A comment line MUST NOT contain any other script command or text BEFORE the '##'.
## 3. A comment line MUST NOT have any script command or text AFTER the comment text on the SAME line.
##
## IN OTHER WORDS: A '##' comment ALWAYS OCCUPIES ITS OWN LINE.
##
## ***** INLINE COMMENT STRICTLY FORBIDDEN:THEY WILL BREAK THE SCRIPT PARSER. *****
##
## CORRECT USAGE:
## This is a standalone comment.
#Show: "This is a command"
## This is another standalone comment following a command.
##
## INCORRECT USAGE (DO NOT EVER DO THIS):
#Show: "text" ## This is an INVALID inline comment.
#Text: variable ## Also INVALID.
"text"
##
## IF YOU WRITE AN INLINE COMMENT, THE SCRIPT WILL FAIL.
## ALWAYS PLACE COMMENTS ON A SEPARATE, DEDICATED LINE.
## --- End of Comment Syntax ---

## The user can not ever input an empty response, so never assume that, for example dont look for #If [answer]="" #Begin 
## IMPORTANT: The user can not press ENTER only, they need to input something first, so it you ask for a default answer maby say "Press 'e' for english" and not "Press Enter for default"
## for the questions where you have a suggested answer, please make it fast and easy for the user to give that answer for example by saying "Press 'e' for english", do this for ALL suggested answers
## So, always use a quick key like "e" to keep the old/suggested/default answer

## Always try to minimize and simplify user input, try to suggest good defaults, make choice menus instead of free text inputs etc

## line breaks are important, for example:
#Text: variable 
"text"
#If [variable]="text" #Begin
## However the #Show command should have the text start on the same line: #Show: "text"


#Show: "text" 
## to show a text to the user, "...text must start on the SAME line as #Show: as in the example
## standard markup is supported, for example **bold** and ## headline 2 ## 
## line breaks are respected, and can also be forced with \n

#Question: variable 
"text" 
## to ask the user a question and store it in a variable 
## IMPORTANT: The content "..." must start on a new line as in the example
## the user can not answer with nothing, like "", it is not possible in the user interface
## questions can refer to [varaiable]
## when refering to a question [variable] will contain the user input, and [variable.q] will contain the question text asked

## variables names are case sensitive

#Text: variable 
"text"
## to store a string in a variable
## when a menu is not llm generated but fixed, start with storing it once in a variable and then use that to reference the menu
## strings do not support math, like: "[variable]+1" 
## IMPORTANT: The content "..." must start on a new line as in the example
## IMPORTANT: the same variable name can be used for #Text: and #Question: and will then share the data, however other keyword types should not share the same variable name, for example this sequence is NOT allowed:
#Text: aaa
""
#chatGPT: aaa
"prompt"


#Text: variable
"[variable]\nNew content"
## example of use of variables in strings


#chatGPT: variable
"prompt"
## to call chatGPT 4o API with a prompt
## can not search the web
## #chatGPT: calls will retain context from old calls, so use that to ask follow up questions or for example select from a generated number or choices. If you call #chatGPT: with a new variable name, there wil be no context to refer to.
## if the llm call like chatGPT did not generate a menu for example, you need to provide that menu for reference when making a choice from it.
## the prompt for a new llm call needs to contain the actual menu a user choice is refering to, not just the users answer 
## llm variables are not the same type as #Text or #Question variables, so you can not do for example: 
#Text: variable
"text"
#chatgpt: variable
"prompt"

#chatGPT35: variable
"prompt"
## older version of chatGPT, way cheaper, can be used for simple tasks
## use this ONLY for VERY simple tasks, like "show me text nr3 from this list of 4 texts"
## do not use if for any kind of analysis or extracting data from raw web content for example
## can not search the web

#claude: variable
"prompt"
## was claude 3.5 sonnet, now 4.5 
## can not search the web
## For final writing it is often better to call claude than chatGPT 

#gemini: variable
"prompt"
## gemini 2.5 pro preview
## can search the web and provide links
## Gemini supports longer output


##The script language supports flushing the context window for an llm variable, this can be useful in specific situations like in a loop where we dont want the old context to remain, to save tokens or to start with a clean context)
#chatGPT: var
"--flush"
#chatGPT35: var
"--flush"
#claude: var
"--flush"
#gemini: var
"--flush"


#Scrape: variable
"url"
## to scrape the contents of a single web page using jina.ai
## will return a json with title, description, html contents etc
## use gemini to clean the raw scraped data, chatgpt can give an error for some site, probably if they are too big

####meta title, description not working?
#scrape: content2
"Title :[url]"

## scrape only H1
#scrape: content3
"h1 :[url]"

## scrape only P
#scrape: content4
"p :[url]"

## scrape only Title, H1, P
#scrape: content5
"title, h1, p :[url]"




#chatgptsearch: variable
"search terms"
## web search, returns a summary + source links, will remember the contect if called with the same variable again




##generate image using chatgpt: gpt image 1
##Supported Sizes: 1024x1024, 1024x1536, 1536x1024, auto (defaults to 1024x1024)
#chatgpt-img: img
size: widthxheight
"[prompt]"

##generate image using gemini 2.5 Flash Image Preview (nano-banana)
##Supported Sizes: only defaults to 1024x1024
#gemini-img: img
"[prompt]"

##show an image to the user, allowing download also
#showimage: [img]



##API access for a large number of SEO oriented endpoints from dataforseo - see documentation: https://docs.dataforseo.com/v3/
##The input is the endpoint url + the json with input data for the endpoint.
##The url and json can most easily be generated in their playground: https://app.dataforseo.com/api-playground/serp
##Note that some endpoint json input data need https://www and some should not have it in an url/domain name
##Also note that sometimes the language can only be selected from a valid list for the chosen country, USA=english+spanish for example
##quotation marks are allowed in the json, and purposewrite script variable can be accessed by ${variable_name} in the json - example:
#SEOkw: seo_answer
URL = https://api.dataforseo.com/v3/serp/google/organic/live/advanced
JSON = {"keyword":"${kw}", "location_code":${location}, "language_code":"${language}", "device":"desktop", "os":"windows", "depth":30, "load_async_ai_overview":true, "people_also_ask_click_depth":4}
##The file SEO.txt gives examples of exactly how to use each endpoint.

#If [variable]="text" #Begin
...
#Else-Begin
...
#End
## Note the ususual syntax for #Else-Begin
## IMPORTANT: #Begin is needed, and on the same line
## The statements after the #If #Begin must come on a new line, not the same line. 


#Loop-Until: [variable]="text"
...
#End
## loop, does not support OR, AND etc, only = and <>
## Note no #Begin is used


## if and loop supports complex conditions: and, or, not, <,>, <=, >=, =, <>, () 
## Matching only the whole string, not parts
## For example: ((([ a ] = "1") and ([ b ] = "2") ) or ( not ([ c ] = "4")))


##Special multi list code to present a menu to the user, let the user select multiple choices and then ask the user about each choice
#Multi-List: expertise
#Start-List: "The choices are:"
#List: "1. Choice 1 - The prompt for choice 1
2. Choice 2 - The prompt for choice 2
3. Choice 3 - The prompt for choice 3"
#End-List: "Please choose (multi choice is ok eg 1,3)"
## this will display a multi-list menu and lets the user reply with a comma separated list of numbers in a string 

##Loop over all choices from a #Multi-List: and build a prompt from the choices made
#Text: expertise_prompt
""
#For-All i=[expertise] #Begin
    #Question: expertise_part{i}
    "Regarding [expertise.i]\nWhat is YOUR input about that area?"

    #Text: expertise_prompt
    "[expertise_prompt]\n[expertise.i] : [expertise_part{i}]"
#End

